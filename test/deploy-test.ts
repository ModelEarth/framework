import assert, {fail} from "node:assert";
import {Readable, Writable} from "node:stream";
import {normalizeConfig} from "../src/config.js";
import type {DeployEffects} from "../src/deploy.js";
import {deploy} from "../src/deploy.js";
import {isHttpError} from "../src/error.js";
import type {Logger} from "../src/logger.js";
import {commandRequiresAuthenticationMessage} from "../src/observableApiAuth.js";
import type {DeployConfig} from "../src/observableApiConfig.js";
import {composeTest} from "./mocks/composeTest.js";
import {withJsDelivrMock} from "./mocks/jsdelivr.js";
import {MockLogger} from "./mocks/logger.js";
import {
  invalidApiKey,
  userWithTwoWorkspaces,
  userWithZeroWorkspaces,
  validApiKey,
  withObservableApiMock
} from "./mocks/observableApi.js";
import {withUndiciAgent} from "./mocks/undiciAgent.js";

// These files are implicitly generated by the CLI. This may change over time,
// so theyâ€™re enumerated here for clarity. TODO We should enforce that these
// files are specifically uploaded, rather than just the number of files.
const EXTRA_FILES: string[] = [
  "_observablehq/client.js",
  "_observablehq/runtime.js",
  "_observablehq/stdlib.js",
  "_observablehq/stdlib/dot.js",
  "_observablehq/stdlib/duckdb.js",
  "_observablehq/stdlib/mermaid.js",
  "_observablehq/stdlib/sqlite.js",
  "_observablehq/stdlib/tex.js",
  "_observablehq/stdlib/xslx.js",
  "_observablehq/style.css"
];

class MockDeployEffects implements DeployEffects {
  public logger = new MockLogger();
  public input = new Readable();
  public output: NodeJS.WritableStream;
  public _observableApiKey: string | null = null;
  public _deployConfig: DeployConfig | null = null;
  public _projectSlug = "my-project-slug";

  constructor({
    apiKey = validApiKey,
    deployConfig = null
  }: {apiKey?: string | null; deployConfig?: DeployConfig | null} = {}) {
    this._observableApiKey = apiKey;
    this._deployConfig = deployConfig;
    const that = this;
    this.output = new Writable({
      write(data, _enc, callback) {
        const dataString = data.toString();
        if (dataString == "New project name: ") {
          that.input.push(`${that._projectSlug}\n`);
          // Having to null/reinit input seems wrong.
          // TODO: find the correct way to submit to readline but keep the same
          // input stream across multiple readline interactions.
          that.input.push(null);
          that.input = new Readable();
        } else if (dataString.includes("Choice: ")) {
          that.input.push("1\n");
          that.input.push(null);
          that.input = new Readable();
        }
        callback();
      }
    });
  }

  async getObservableApiKey(logger: Logger) {
    if (!this._observableApiKey) {
      logger.log(commandRequiresAuthenticationMessage);
      throw new Error("no key available in this test");
    }
    return {source: "test" as const, key: this._observableApiKey};
  }

  async getDeployConfig() {
    return this._deployConfig;
  }

  async setDeployConfig(sourceRoot: string, config: DeployConfig) {
    this._deployConfig = config;
  }
}

// This test should have exactly one index.md in it, and nothing else; that one
// page is why we +1 to the number of extra files.
const TEST_SOURCE_ROOT = "test/input/build/simple-public";
const TEST_CONFIG = await normalizeConfig({root: TEST_SOURCE_ROOT});

// TODO These tests need mockJsDelivr, too!
describe("deploy", () => {
  composeTest(
    "makes expected API calls for a new project",
    withUndiciAgent(),
    withObservableApiMock(),
    withJsDelivrMock(),
    async ({observableApiMock}) => {
      const projectId = "project123";
      const deployId = "deploy456";

      observableApiMock
        .handleGetUser()
        .handlePostProject({projectId})
        .handlePostDeploy({projectId, deployId})
        .handlePostDeployFile({deployId, repeat: EXTRA_FILES.length + 1})
        .handlePostDeployUploaded({deployId})
        .done();

      const effects = new MockDeployEffects();
      await deploy({config: TEST_CONFIG}, effects);

      const deployConfig = await effects.getDeployConfig();
      assert.equal(deployConfig?.project?.id, projectId);
      assert.equal(deployConfig?.project?.slug, effects._projectSlug);
    }
  );

  composeTest(
    "makes expected API calls for an existing project",
    withUndiciAgent(),
    withObservableApiMock(),
    withJsDelivrMock(),
    async ({observableApiMock}) => {
      const projectId = "project123";
      const deployConfig = {project: {id: projectId}};
      const deployId = "deploy456";
      observableApiMock
        .handlePostDeploy({projectId, deployId})
        .handlePostDeployFile({deployId, repeat: EXTRA_FILES.length + 1})
        .handlePostDeployUploaded({deployId})
        .done();

      const effects = new MockDeployEffects({deployConfig});
      await deploy({config: TEST_CONFIG}, effects);
    }
  );

  composeTest("shows message for missing API key", withUndiciAgent(), withObservableApiMock(), async () => {
    const effects = new MockDeployEffects({apiKey: null});

    try {
      await deploy({config: TEST_CONFIG}, effects);
      assert.fail("expected error");
    } catch (err) {
      if (!(err instanceof Error)) throw err;
      assert.equal(err.message, "no key available in this test");
      effects.logger.assertExactLogs([/^You need to be authenticated/]);
    }
  });

  composeTest(
    "handles multiple user workspaces",
    withUndiciAgent(),
    withObservableApiMock(),
    withJsDelivrMock(),
    async ({observableApiMock}) => {
      const projectId = "project123";
      const deployId = "deploy456";
      observableApiMock
        .handleGetUser({user: userWithTwoWorkspaces})
        .handlePostProject({projectId})
        .handlePostDeploy({projectId, deployId})
        .handlePostDeployFile({deployId, repeat: EXTRA_FILES.length + 1})
        .handlePostDeployUploaded({deployId})
        .done();
      const effects = new MockDeployEffects();

      await deploy({config: TEST_CONFIG}, effects);

      const deployConfig = await effects.getDeployConfig();
      assert.equal(deployConfig?.project?.id, projectId);
      assert.equal(deployConfig?.project?.slug, effects._projectSlug);
    }
  );

  composeTest(
    "logs an error during project creation when user has no workspaces",
    withUndiciAgent(),
    withObservableApiMock(),
    async ({observableApiMock}) => {
      observableApiMock.handleGetUser({user: userWithZeroWorkspaces}).done();
      const effects = new MockDeployEffects();
      await deploy({config: TEST_CONFIG}, effects);
      effects.logger.assertExactErrors([/^Current user doesn't have any Observable workspaces/]);
    }
  );

  composeTest(
    "throws an error with an invalid API key",
    withUndiciAgent(),
    withObservableApiMock(),
    async ({observableApiMock}) => {
      observableApiMock.handleGetUser({status: 401}).done();
      const effects = new MockDeployEffects({apiKey: invalidApiKey});

      try {
        await deploy({config: TEST_CONFIG}, effects);
        assert.fail("Should have thrown");
      } catch (error) {
        assert.ok(isHttpError(error));
        assert.equal(error.statusCode, 401);
      }
    }
  );

  composeTest(
    "throws an error if project creation fails",
    withUndiciAgent(),
    withObservableApiMock(),
    async ({observableApiMock}) => {
      observableApiMock.handleGetUser().handlePostProject({status: 500}).done();
      const effects = new MockDeployEffects();

      try {
        await deploy({config: TEST_CONFIG}, effects);
        fail("Should have thrown an error");
      } catch (error) {
        assert.ok(isHttpError(error));
        assert.equal(error.statusCode, 500);
      }
    }
  );

  composeTest(
    "throws an error if deploy creation fails",
    withUndiciAgent(),
    withObservableApiMock(),
    async ({observableApiMock}) => {
      const projectId = "project123";
      const deployId = "deploy456";
      observableApiMock
        .handleGetUser()
        .handlePostProject({projectId})
        .handlePostDeploy({projectId, deployId, status: 500})
        .done();
      const effects = new MockDeployEffects();

      try {
        await deploy({config: TEST_CONFIG}, effects);
        fail("Should have thrown an error");
      } catch (error) {
        assert.ok(isHttpError(error));
        assert.equal(error.statusCode, 500);
      }
    }
  );

  composeTest(
    "throws an error if file upload fails",
    withUndiciAgent(),
    withObservableApiMock(),
    async ({observableApiMock}) => {
      const projectId = "project123";
      const deployId = "deploy456";
      observableApiMock
        .handleGetUser()
        .handlePostProject({projectId})
        .handlePostDeploy({projectId, deployId})
        .handlePostDeployFile({deployId, status: 500})
        .done();
      const effects = new MockDeployEffects();

      try {
        await deploy({config: TEST_CONFIG}, effects);
        fail("Should have thrown an error");
      } catch (error) {
        assert.ok(isHttpError(error));
        assert.equal(error.statusCode, 500);
      }
    }
  );

  composeTest(
    "throws an error if deploy uploaded fails",
    withUndiciAgent(),
    withObservableApiMock(),
    withJsDelivrMock(),
    async ({observableApiMock}) => {
      const projectId = "project123";
      const deployId = "deploy456";
      observableApiMock
        .handleGetUser()
        .handlePostProject({projectId})
        .handlePostDeploy({projectId, deployId})
        .handlePostDeployFile({deployId, repeat: EXTRA_FILES.length + 1})
        .handlePostDeployUploaded({deployId, status: 500})
        .done();
      const effects = new MockDeployEffects();

      try {
        await deploy({config: TEST_CONFIG}, effects);
        fail("Should have thrown an error");
      } catch (error) {
        if (!isHttpError(error)) throw error;
        assert.ok(isHttpError(error));
        assert.equal(error.statusCode, 500);
      }
    }
  );
});
